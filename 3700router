#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, sys, math


class Router:
	relations = {}
	sockets = {}
	ports = {}
	# array with routing table entries (list of dictionaries)
	routing_table = []

	saved_msg = []
	NO_ROUTE = {"src": "", "dst": "", "type": "no route", "msg": {}}

	def __init__(self, asn, connections):
		print("Router at AS %s starting up" % asn)
		self.asn = asn
		for relationship in connections:
			port, neighbor, relation = relationship.split("-")

			self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
			self.sockets[neighbor].bind(('localhost', 0))
			self.ports[neighbor] = int(port)
			self.relations[neighbor] = relation
			self.send(
			 neighbor,
			 json.dumps({
			  "type": "handshake",
			  "src": self.our_addr(neighbor),
			  "dst": neighbor,
			  "msg": {}
			 }))

	# Transform network into masked binary representation. Return the
	# binary without the last digit as a string
	def into_ip(entry):
		ip = list(str(bin(int(qdn))) for qdn in entry["network"].split('.'))
		prefix = list(str(bin(int(qdn))) for qdn in entry["netmask"].split('.'))
		prefix = "".join(prefix).count('1') - 1
		return ip[:prefix]

	def send_data(self, rt_index, src, inmsg):
		entry = self.routing_table[rt_index]
		dst = entry["peer"]
		if self.relations[src] == "cust" or self.relations[dst] == "cust":
			self.send(dst, json.dumps(inmsg))
		else:
			self.send(src, json.dumps(self.NO_ROUTE))

	def our_addr(self, dst):
		quads = list(int(qdn) for qdn in dst.split('.'))
		quads[3] = 1
		return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

	def send(self, network, message):
		self.sockets[network].sendto(message.encode('utf-8'),
		                             ('localhost', self.ports[network]))

	def run(self):
		while True:
			socks = select.select(self.sockets.values(), [], [], 0.1)[0]
			for conn in socks:
				k, addr = conn.recvfrom(65535)
				srcif = None
				for sock in self.sockets:
					if self.sockets[sock] == conn:
						srcif = sock
						break
				msg = k.decode('utf-8')
				print("Received message '%s' from %s" % (msg, srcif))
				# code here

				inmsg = json.loads(msg)
				# if this is an update type message
				if inmsg["type"] == "update":
					self.saved_msg.append(inmsg["msg"])
					# get msg from the update message
					update_msg = inmsg["msg"]
					# add current AS to ASPath
					ASPath = [args.asn] + update_msg["ASPath"]
					# append new routing table entry
					self.routing_table.append({
					 "network": update_msg["network"],
					 "netmask": update_msg["netmask"],
					 "peer": inmsg["src"],
					 "localpref": update_msg["localpref"],
					 "selfOrigin": update_msg["selfOrigin"],
					 "ASPath": update_msg["ASPath"],
					 "origin": update_msg["origin"]
					})
					# If customer send to remaining neighbor, else send to remaining customers
					for neighbor in self.relations.keys():
						if neighbor != inmsg["src"] and (self.relations[neighbor] == "cust" or
						                                 self.relations[inmsg["src"]] == "cust"):
							self.send(
							 neighbor,
							 json.dumps({
							  "type": "update",
							  "src": self.our_addr(neighbor),
							  "dst": neighbor,
							  "msg": {
							   "network": update_msg["network"],
							   "netmask": update_msg["netmask"],
							   "ASPath": ASPath
							  }
							 }))
				# # only need to check if the newest entry is dup
				#     newest = routing_table[len(routing_table) - 1]
				# cut_newest = newest
				# cut_newest.pop("network")
				# cut_newest.pop("netmask")
				#     for i in range(len(routing_table) - 1):
				#       cur = routing_table[i]
				# 	cut_cur = cur
				# 	cut_cur.pop("network")
				# 	cut_cur.pop("netmask")
				#       if into_ip(newest) == into_ip(cur) and cut_newest == cut_cur:
				#         routing_table[i]["network"] =
				#         routing_table[i]["netmask"]--
				#         routing_table = routing_table[0:len(routing_table) - 1]
				#         break
				#       i++

				if inmsg["type"] == "withdraw":
					# Save message
					self.saved_msg.append(inmsg["msg"])
					# Remove dead entry from the routing table
					for dead_entry in inmsg["msg"]:
						rt = self.routing_table
						self.routing_table = [
						 entry for entry in rt
						 if entry["network"] != dead_entry["network"] or entry["netmask"] !=
						 dead_entry["netmask"] or entry["peer"] != inmsg["src"]
						]
					# If customer send to remaining neighbor, else send to remaining customers
					for neighbor in self.relations.keys():
						if neighbor != inmsg["src"] and (self.relations[neighbor] == "cust" or
						                                 self.relations[inmsg["src"]] == "cust"):
							self.send(
							 neighbor,
							 json.dumps({
							  "type": "withdraw",
							  "src": self.our_addr(neighbor),
							  "dst": neighbor,
							  "msg": inmsg["msg"]
							 }))

				if inmsg["type"] == "data":
					# A string binary of the destination ip
					dst_ip = list(str(bin(int(qdn))) for qdn in inmsg["dst"].split('.'))
					dst_ip = "".join(dst_ip)

					matching_entries = []
					table_index = 0
					for entry in self.routing_table:
						# A string binary of an ip from the routing table
						ip = list(str(bin(int(qdn))) for qdn in entry["network"].split('.'))
						ip = "".join(ip)
						# Prefix of the netmask which then could be use to compare the destination and current ip
						prefix = list(str(bin(int(qdn))) for qdn in entry["netmask"].split('.'))
						prefix = "".join(prefix).count('1')
						dst_ip_cut = dst_ip[:prefix]
						table_ip_cut = ip[:prefix]

						# if dst ip matches the table ip, add the table index to matching_entries
						if dst_ip_cut == table_ip_cut:
							matching_entries.append(table_index)
						table_index += 1

					if self.relations[srcif] != "cust":
						matching_entries = [entry for entry in matching_entries if self.relations[self.routing_table[entry]["peer"]] == "cust"]
					if len(matching_entries) == 0:
						self.send(srcif, json.dumps(self.NO_ROUTE))
					if len(matching_entries) == 1:
						self.send_data(matching_entries[0], srcif, inmsg)
					# else check first step - highest localpref
					else:
						highest_localpref = -1
						for entry in matching_entries:
							rt_entry = self.routing_table[entry]
							if highest_localpref < rt_entry["localpref"]:
								highest_localpref = rt_entry["localpref"]
						matching_entries = [
						 entry for entry in matching_entries
						 if self.routing_table[entry]["localpref"] == highest_localpref
						]
						if len(matching_entries) == 1:
							self.send_data(matching_entries[0], srcif, inmsg)
						# else check second step - true selforigin
						else:
							matching_entries = [
							 entry for entry in matching_entries
							 if self.routing_table[entry]["selfOrigin"]
							]
							if len(matching_entries) == 1:
								self.send_data(matching_entries[0], srcif, inmsg)
							# else check third step - shortest ASPath
							else:
								shortest_ASPath = 10000000
								for entry in matching_entries:
									rt_entry = self.routing_table[entry]
									if shortest_ASPath > len(rt_entry["ASPath"]):
										shortest_ASPath > len(rt_entry["ASPath"])
								matching_entries = [
								 entry for entry in matching_entries
								 if len(self.routing_table[entry]["ASPath"]) == shortest_ASPath
								]
								if len(matching_entries) == 1:
									self.send_data(matching_entries[0], srcif, inmsg)
								# else check fourth step - origin - check if not UNK first
								else:
									temp_entries = [
									 entry for entry in matching_entries
									 if self.routing_table[entry]["origin"] != "UNK"
									]
									if len(temp_entries) != 0:
										matching_entries = temp_entries
									if len(matching_entries) == 1:
										self.send_data(matching_entries[0], srcif, inmsg)
									# else check fourth step - origin - check if not EGP now
									else:
										temp_entries = [
										 entry for entry in matching_entries
										 if self.routing_table[entry]["origin"] != "UNK"
										 and self.routing_table[entry]["origin"] != "EGP"
										]
										if len(temp_entries) != 0:
											matching_entries = temp_entries
										if len(matching_entries) == 1:
											self.send_data(matching_entries[0], srcif, inmsg)
										#else check fifth step - lowest ip address
										else:
											lowest_ip = math.inf
											lowest_entry = -1
											for entry in matching_entries:
												rt_src = self.routing_table[entry]["peer"]
												cur_ip = list(str(bin(int(qdn))) for qdn in rt_src.split('.'))
												cur_ip = float("".join(cur_ip))
												if lowest_ip > cur_ip:
													lowest_ip = cur_ip
													lowest_entry = entry

											entry = self.routing_table[lowest_entry]
											self.send_data(lowest_entry, srcif, inmsg)

# Dump routing table if dump message
				if inmsg["type"] == "dump":
					rt_json = {
					 "src": self.our_addr(inmsg["src"]),
					 "dst": inmsg["src"],
					 "type": "table",
					 "msg": self.routing_table
					}
					self.send(inmsg["src"], json.dumps(rt_json))

		return

if __name__ == "__main__":
	parser = argparse.ArgumentParser(description='route packets')
	parser.add_argument('asn', type=int, help="AS number of this router")
	parser.add_argument('connections',
	                    metavar='connections',
	                    type=str,
	                    nargs='+',
	                    help="connections")
	args = parser.parse_args()
	router = Router(args.asn, args.connections)
	router.run()
