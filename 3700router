#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, sys, math

saved_msg = []
NO_ROUTE = {"src": "", "dst": "", "type": "no route", "msg": {}}


class Router:

	relations = {}
	sockets = {}
	ports = {}
	# array with routing table entries (list of dictionaries)
	routing_table = []

	def __init__(self, asn, connections):
		print("Router at AS %s starting up" % asn)
		self.asn = asn
		for relationship in connections:
			port, neighbor, relation = relationship.split("-")

			self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
			self.sockets[neighbor].bind(('localhost', 0))
			self.ports[neighbor] = int(port)
			self.relations[neighbor] = relation
			self.send(
			 neighbor,
			 json.dumps({
			  "type": "handshake",
			  "src": self.our_addr(neighbor),
			  "dst": neighbor,
			  "msg": {}
			 }))

	def our_addr(self, dst):
		quads = list(int(qdn) for qdn in dst.split('.'))
		quads[3] = 1
		return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

	def send(self, network, message):
		self.sockets[network].sendto(message.encode('utf-8'),
		                             ('localhost', self.ports[network]))

	def run(self):
		while True:
			socks = select.select(self.sockets.values(), [], [], 0.1)[0]
			for conn in socks:
				k, addr = conn.recvfrom(65535)
				srcif = None
				for sock in self.sockets:
					if self.sockets[sock] == conn:
						srcif = sock
						break
				msg = k.decode('utf-8')
				print("Received message '%s' from %s" % (msg, srcif))
				# code here

				inmsg = json.loads(msg)
				# if this is an update type message
				if inmsg["type"] == "update":
					saved_msg.append(inmsg)
					# get msg from the update message
					update_msg = inmsg["msg"]
					# add current AS to ASPath
					ASPath = [args.asn] + update_msg["ASPath"]
					# append new routing table entry
					self.routing_table.append({
					 "network": update_msg["network"],
					 "netmask": update_msg["netmask"],
					 "peer": inmsg["src"],
					 "localpref": update_msg["localpref"],
					 "selfOrigin": update_msg["selfOrigin"],
					 "ASPath": update_msg["ASPath"],
					 "origin": update_msg["origin"]
					})
          # If customer send to remaining neighbor, else send to remaining customers
					for neighbor in self.relations.keys():
						if neighbor != inmsg["src"] and (self.relations[neighbor] == "cust" or
						                                 self.relations[inmsg["src"]] == "cust"):
							self.send(
							 neighbor,
							 json.dumps({
							  "type": "update",
							  "src": self.our_addr(neighbor),
							  "dst": neighbor,
							  "msg": {
							   "network": update_msg["network"],
							   "netmask": update_msg["netmask"],
							   "ASPath": ASPath
							  }
							 }))

				if inmsg["type"] == "withdraw":
					print("foo")

				if inmsg["type"] == "data":
          # A string binary of the destination ip
          dst_ip = list(str(bin(int(qdn))) for qdn in dst.split('.'))
          dst_ip = join(dst_ip)

					matching_entries = []
					table_index = 0
					for entry in self.routing_table:
            # A string binary of an ip from the routing table
						ip = list(str(bin(int(qdn))) for qdn in entry["network"].split('.'))
						ip = join(ip)
            # Prefix of the netmask which then could be use to compare the destination and current ip
						prefix = list(str(bin(int(qdn))) for qdn in entry["netmask"].split('.'))
						prefix = join(prefix).count('1')
						dst_ip_cut = dst_ip[:prefix]
						table_ip_cut = ip[:prefix]
            
						# if dst ip matches the table ip, add the table index to matching_entries
						if dst_ip_cut == table_ip_cut:
							matching_entries.append(table_index)
						table_index += 1

					# if only one matching IP, send to that peer
					if len(matching_entries) == 1:
						entry = self.routing_table[matching_entries[0]]
						self.send(
						 entry["peer"],
						 json.dumps(inmsg))
					else:
						#TODO
        # Dump routing table if dump message
				if inmsg["type"] == "dump":
					rt_json = {
					 "src": self.our_addr(inmsg["src"]),
					 "dst": inmsg["src"],
					 "type": "table",
					 "msg": self.routing_table
					}
					self.send(inmsg["src"], json.dumps(rt_json))
		return

if __name__ == "__main__":
	parser = argparse.ArgumentParser(description='route packets')
	parser.add_argument('asn', type=int, help="AS number of this router")
	parser.add_argument('connections',
	                    metavar='connections',
	                    type=str,
	                    nargs='+',
	                    help="connections")
	args = parser.parse_args()
	router = Router(args.asn, args.connections)
	router.run()
